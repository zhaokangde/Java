# Authorization workflow

The authorization is done in two phases.

In the first phase, an ID JWT token with the Authentication information is generated when the user logins in the application. The picture workflow illustrates how this is done. The section **KeyCloak Protocol Mapper** explains this part with more detail.

![TOKEN](security_Authentication/IDToken.svg)

In the second phase, the MMF application verifies in KeyCloak if the user has access to the requested URL by accessing. The section **KeyCloak Policy** explains this part with more detail.

![TOKEN](security_Authentication/UserAuthorization.svg)

More details about token generation and MMF policy are available at [KeyCloak Policy and Token](#keycloak-policy-token)

* Cadastrar um novo resource.
## Create a new authorization to a MMF Resource
* Create Client Resource
    * Select `Clients` tab on keycloak admin panel's side bar 
    * Select desired Client
    * Select `Authorization` > `Resources` 
    * Click on Create button.
        * A few parameters must be set in the resource:
            * "Name" : Alias to the Resource
            * "Display Name" : name to be displayed on Keycloak interface
            * "URI" : List of URI that represent the MMF endpoints that must Authorized for this Resource.
            * "scope" : scopes of the URI's to be Authorized for this Resource.
        * Usually, resources groups it's URIS in three scope groups:
            * Add and Edit
            * Search
            * Delete  
        Is recomended that each scope group have a Keycloak Resource.
        
        * Ex.:
              ![role miami admin](security_Authentication/ResourceCreation/MMFCreatedResource.png)
* Grant Resource Permission to Operation roles
    *  Create Role
         * Select `Role` tab on keycloak admin panel's side bar 
         * Click on `Add role` and create a new role
            * Click on `Attributes`
                * Here is where the user receive permission to the scopes. 
                    * Create a new attribute for each scope group that should be granted to the user.
                    * Ex.: 
                        ![role miami admin](security_Authentication/ResourceCreation/RoleEngineer.png)
       

# Front-end
Front-end will be responsible for hide labels and disable buttons that user have no permission to access. It is done by a directive called "hasPermission".

## Using "hasPermission" directive
It is necessary to add the property `v-has-permission` on component or element that needs permission and pass the permission name that will be evaluated.

An example is shown below for Add Button on systemParametersList view: 

```
    <mmf-button type="add"
             show-name
             v-has-permission="'scope.systemParameters.addEdit'"
             v-bind:class="'btn btn-outline-primary'"
             v-on:click="MMFNew('systemParameters')">
    </mmf-button>
```

# Accessing role parameters on backend logic
Role parameters can be accessed on backend by deserializing the JWT token generated by KeyCloak.
* Ex.: Extract user Location from the KeyCloak JWT token and find equipments which can be seen.
 
 As the `EquipmentResource.java` is the REST EndPoint for the Equipment, is possible to retreive the HTTP Request header
  in which is contained the JWT token. Calling the `ImplicitFilterService.java` method `getLocationImplictFilterFromHeader()`
  will extract an `ImplicitFilter.java`. 
  
  The parameters for this function are the header from requisition and the scope for this resource.
  In order to have permission on this resource the user must have this scope defined in the User Role. For the Miami example,
   the `role_admin` or `role_user` must have this information.  
   
 
 `EquipmentResource.java`
 ```java
     ... import statements ...
 @RestController
 @RequestMapping("/master/equipment")
 public class EquipmentResource {
 
     private static String SCOPE_SEARCH = "scope.equipment.search";
 
     @Autowired
     EquipmentService equipmentService;
    
     @Autowired
     ImplicitFilterService implicitFilterService;
 
     ... Other objects injected into class ...
 
     @GetMapping(path = "/findAll", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
     ResponseEntity<Iterable<Equipment>> findAll(@RequestHeader HttpHeaders incommingHeaders) {
         try {
             ImplicitFilter implicitFilter = implicitFilterService.getLocationImplictFilterFromHeader(incommingHeaders, SCOPE_SEARCH);
             Iterable<Equipment> equipments = equipmentService.findAll(implicitFilter);
             return new ResponseEntity<>(equipments, HttpStatus.OK);
         } catch (Exception ex) {
            ... Handle Exception ...
         }
     }
 
     ... Other EquipmentResource methods ... 
 }
 ```
        
  `ImplicitFilter.java`      
```java
    ... import statements ...
public class ImplicitFilter {

    private List<Long> locations;

    public ImplicitFilter(List<Long> locations) {
        this.locations = locations;
    }

    public List<Long> getLocations() {
        return locations;
    }
}
```
  This class will hold any parameter, in this case, it's implemented to hold the ids for the user's location as
   an instance of List\<Long>.
  
`ImplicitFilterService.java`
```java
    ... import statements ...
@Service
public class ImplicitFilterService {
    @Autowired
    JwtParserService jwtParserService;


    public ImplicitFilter getLocationImplictFilterFromHeader(HttpHeaders headers, String scope) throws JSONException {
        String token = headers.get("authorization").get(0).replace("Bearer ","");
        JSONObject object = jwtParserService.getObjectFromJWTTokenOnSegment(token,"userRolesAttributes", JWTSegment.BODY);
        JSONObject scopeObject = object.getJSONObject(scope);
        Iterator<String> keys = scopeObject.keys();

        List<Long> locationsId = new ArrayList<>();
        locationsId.add(-1L);
        while(keys.hasNext()) {
            String key = keys.next();
            if (scopeObject.get(key) instanceof JSONObject) {
                Long locationId = ((JSONObject) scopeObject.get(key)).getLong("location");
                locationsId.add(locationId);
            }
        }

        return new ImplicitFilter(locationsId);
    }
}
```
`JwtParserService.java` is implemented to convert the JWT Token into an JSONObject. 
It's method `getObjectFromJWTTokenOnSegment` extracts any attribute on JWT Token based on the token, 
he name of the attribute and the segment of the token in which it's located.
for this implementation, the object `userRolesAttributes` is expected in the following structure :
```javascript
 "userRolesAttributes":{
        "scope.equipments.search": {
              "0": {
                "location": "1"
              },
              "1": {
                "location": "2"
              }
            },
       "scope.equipment.view": {
              "0": {
                "location": "1"
              },
              "1": {
                "location": "2"
              }
            },
    }
```
After access the element correspondent to the scope of the desired resource, is possible
 to iterate over the user's location and insert it into the `ImplicitFilter.java` to be used on the query that search for all
 Equipments.      
 
 # Keycloak Policy Token

In KeyCloak, the authorization information are retrieved by JWT Token. An introduction about this subject can be found at https://jwt.io/introduction/.

MMF sends Authorization information in custom JWT attribute using KeyCloak custom protocol mapper as follows:

![mmf-protocol-mapper](security_Authentication/mmf-protocol-mapper.jpg)
 
The verification if an user has access to a given URL is done by the MMF Policy as follows:
 
![mmf-policy.jpg](security_Authentication/mmf-policy.jpg)
 
